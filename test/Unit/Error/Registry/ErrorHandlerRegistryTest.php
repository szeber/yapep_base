<?php
declare(strict_types=1);

namespace PHPUnit\Framework\Error\Registry;

use Mockery\MockInterface;
use YapepBase\Error\Entity\Error;
use YapepBase\Error\Entity\ExceptionEntity;
use YapepBase\Error\Handler\IErrorHandler;
use YapepBase\Error\Helper\ErrorHelper;
use YapepBase\Error\Registry\ErrorHandlerRegistry;
use YapepBase\Error\Registry\IIdGenerator;
use YapepBase\ErrorHandler\ITerminatable;
use YapepBase\Event\Event;
use YapepBase\Event\IEventHandlerRegistry;
use YapepBase\Response\IResponse;
use YapepBase\Test\Unit\TestAbstract;

class ErrorHandlerRegistryTest extends TestAbstract
{
    /** @var IIdGenerator|MockInterface */
    private $idGenerator;
    /** @var ErrorHelper|MockInterface */
    private $errorHelper;
    /** @var IResponse|MockInterface */
    private $response;
    /** @var IErrorHandler|MockInterface */
    private $errorHandler;
    /** @var IEventHandlerRegistry|MockInterface */
    private $eventHandler;
    /** @var ITerminatable|MockInterface */
    private $terminator;
    /** @var int */
    private $originalErrorReportingLevel;
    /** @var int */
    private $errorCode = E_USER_WARNING;
    /** @var string */
    private $message = 'message';
    /** @var string */
    private $file = 'file';
    /** @var int */
    private $line = 2;

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->idGenerator  = \Mockery::mock(IIdGenerator::class);
        $this->errorHelper  = \Mockery::mock(ErrorHelper::class);
        $this->response     = \Mockery::mock(IResponse::class);
        $this->errorHandler = \Mockery::mock(IErrorHandler::class);
        $this->eventHandler = \Mockery::mock(IEventHandlerRegistry::class);
        $this->terminator   = \Mockery::mock(ITerminatable::class);

        $this->originalErrorReportingLevel = error_reporting();
    }

    protected function tearDown(): void
    {
        error_reporting($this->originalErrorReportingLevel);
        parent::tearDown();
    }

    public function testAddErrorHandler_shouldAdd()
    {
        $registry = $this->getErrorHandlerRegistry();
        $handler1 = \Mockery::mock(IErrorHandler::class);
        $handler2 = \Mockery::mock(IErrorHandler::class);

        $registry->addErrorHandler($handler1);
        $registry->addErrorHandler($handler2);

        $registeredErrorHandlers = $registry->getErrorHandlers();
        $this->assertSame($handler1, $registeredErrorHandlers[0]);
        $this->assertSame($handler2, $registeredErrorHandlers[1]);
    }

    public function testRemoveErrorHandler_shouldRemove()
    {
        $registry = $this->getErrorHandlerRegistry();
        $handler1 = \Mockery::mock(IErrorHandler::class);
        $handler2 = \Mockery::mock(IErrorHandler::class);

        $registry->addErrorHandler($handler1);
        $registry->addErrorHandler($handler2);
        $registry->removeErrorHandler($handler1);

        $registeredErrorHandlers = $registry->getErrorHandlers();
        $this->assertSame($handler2, $registeredErrorHandlers[1]);
        $this->assertCount(1, $registeredErrorHandlers);
    }

    public function testHandleErrorWhenNoHandlerRegistered_shouldDoNothing()
    {
        $this->getErrorHandlerRegistry()->handleError(1, 'message', 'file', 2);
        $this->assertTrue(true);
    }

    public function testHandleErrorWhenErrorReportingIgnoresError_shouldDoNothing()
    {
        $registry = $this->getErrorHandlerRegistry();
        $registry->addErrorHandler($this->errorHandler);

        error_reporting(0);
        $registry->handleError(1, 'message', 'file', 2);
        $this->assertTrue(true);
    }

    public function testHandleError_shouldUseErrorHandler()
    {
        $registry = $this->getErrorHandlerRegistry();
        $registry->addErrorHandler($this->errorHandler);

        $this->expectIdGenerated();
        $this->expectErrorHandled();
        $this->expectCheckedIfErrorIsFatal(false);

        $registry->handleError($this->errorCode, $this->message, $this->file, $this->line);
    }

    public function testHandleErrorWhenFatal_shouldSendResponseAndExit()
    {
        $registry = $this->getErrorHandlerRegistry($this->response);
        $registry->addErrorHandler($this->errorHandler);

        $this->expectIdGenerated();
        $this->expectErrorHandled();
        $this->expectCheckedIfErrorIsFatal(true);
        $this->expectSendErrorResponse();
        $this->expectExit();

        $registry->handleError($this->errorCode, $this->message, $this->file, $this->line);
    }

    public function testHandleExceptionWhenNoHandlersRegistered_shouldTriggerError()
    {
        $registry = $this->getErrorHandlerRegistry();

        $this->expectException(\PHPUnit\Framework\Error\Error::class);

        $registry->handleException(new \Exception());
    }

    public function testHandleException_shouldUseErrorHandler()
    {
        $registry = $this->getErrorHandlerRegistry();
        $registry->addErrorHandler($this->errorHandler);

        $this->expectIdGenerated();
        $this->expectExceptionHandled();

        $registry->handleException(new \Exception($this->message, $this->errorCode));
    }

    public function testHandleShutdownWhenNoErrorOccurred_shouldTerminate()
    {
        $errorHandlerRegistry = $this->getErrorHandlerRegistry();

        $this->expectLastError(null);
        $this->expectEventChecked(Event::TYPE_APPLICATION_BEFORE_RUN, true);
        $this->expectExit();

        $errorHandlerRegistry->handleShutdown();
    }

    public function testHandleShutdownWhenErrorNotFatal_shouldTerminate()
    {
        $errorHandlerRegistry = $this->getErrorHandlerRegistry();

        $this->expectLastError(new Error($this->errorCode, $this->message, $this->file, $this->line));
        $this->expectEventChecked(Event::TYPE_APPLICATION_AFTER_RUN, false);
        $this->expectCheckedIfErrorIsFatal(false);
        $this->expectEventChecked(Event::TYPE_APPLICATION_BEFORE_RUN, true);
        $this->expectExit();

        $errorHandlerRegistry->handleShutdown();
    }

    public function testHandleShutdownWhenApplicationRanSuccessfully_shouldTerminate()
    {
        $errorHandlerRegistry = $this->getErrorHandlerRegistry();

        $this->expectLastError(new Error($this->errorCode, $this->message, $this->file, $this->line));
        $this->expectEventChecked(Event::TYPE_APPLICATION_AFTER_RUN, true);
        $this->expectEventChecked(Event::TYPE_APPLICATION_BEFORE_RUN, true);
        $this->expectExit();

        $errorHandlerRegistry->handleShutdown();
    }

    public function testHandleShutdownWhenShouldTerminateAndApplicationNotStartedYet_shouldSendErrorResponse()
    {
        $errorHandlerRegistry = $this->getErrorHandlerRegistry($this->response);

        $this->expectLastError(null);
        $this->expectEventChecked(Event::TYPE_APPLICATION_BEFORE_RUN, false);
        $this->expectSendErrorResponse();
        $this->expectExit();

        $errorHandlerRegistry->handleShutdown();
    }

    public function testHandleShutdownWhenShouldTerminateAndTerminatorAdded_shouldUseTerminator()
    {
        $errorHandlerRegistry = $this->getErrorHandlerRegistry();

        $this->expectTerminatorCalled(false);
        $errorHandlerRegistry->setTerminator($this->terminator);
        $this->expectLastError(null);
        $this->expectEventChecked(Event::TYPE_APPLICATION_BEFORE_RUN, true);
        $this->expectExit();

        $errorHandlerRegistry->handleShutdown();
    }

    public function testHandleShutdownNoErrorHandlers_shouldLogError()
    {
        $errorHandlerRegistry = $this->getErrorHandlerRegistry();

        $this->expectLastError(new Error($this->errorCode, $this->message, $this->file, $this->line));
        $this->expectEventChecked(Event::TYPE_APPLICATION_AFTER_RUN, false);
        $this->expectCheckedIfErrorIsFatal(true);
        $this->expectEventChecked(Event::TYPE_APPLICATION_BEFORE_RUN, true);
        $this->expectErrorLoggedDirectly('No error handlers are defined and a fatal error occurred');
        $this->expectExit();

        $errorHandlerRegistry->handleShutdown();
    }

    public function testHandleShutdown_shouldCallErrorHandlers()
    {
        $errorHandlerRegistry = $this->getErrorHandlerRegistry();
        $errorHandlerRegistry->addErrorHandler($this->errorHandler);

        $this->expectLastError(new Error($this->errorCode, $this->message, $this->file, $this->line));
        $this->expectEventChecked(Event::TYPE_APPLICATION_AFTER_RUN, false);
        $this->expectCheckedIfErrorIsFatal(true);
        $this->expectEventChecked(Event::TYPE_APPLICATION_BEFORE_RUN, true);
        $this->expectIdGenerated();
        $this->expectShutdownHandled();
        $this->expectExit();

        $errorHandlerRegistry->handleShutdown();
    }

    private function expectIdGenerated(): void
    {
        $this->idGenerator->shouldReceive('generateId');
    }

    private function expectErrorHandled(): void
    {
        $this->errorHandler
            ->shouldReceive('handleError')
            ->once()
            ->with(\Mockery::on(function (Error $error) {
                $this->assertSame($this->errorCode, $error->getCode());
                $this->assertSame($this->message, $error->getMessage());
                $this->assertSame($this->file, $error->getFile());
                $this->assertSame($this->line, $error->getLine());
                return true;
            }));
    }

    private function expectExceptionHandled(): void
    {
        $this->errorHandler
            ->shouldReceive('handleException')
            ->once()
            ->with(\Mockery::on(function (ExceptionEntity $exception) {
                $this->assertSame($this->message, $exception->getException()->getMessage());
                $this->assertSame($this->errorCode, $exception->getException()->getCode());
                return true;
            }));
    }

    private function expectShutdownHandled(): void
    {
        $this->errorHandler
            ->shouldReceive('handleShutdown')
            ->once()
            ->with(\Mockery::on(function (Error $error) {
                $this->assertSame($this->errorCode, $error->getCode());
                $this->assertSame($this->message, $error->getMessage());
                $this->assertSame($this->file, $error->getFile());
                $this->assertSame($this->line, $error->getLine());
                return true;
            }));
    }

    private function expectCheckedIfErrorIsFatal(bool $expectedResult): void
    {
        $this->errorHelper
            ->shouldReceive('isFatal')
            ->once()
            ->with($this->errorCode)
            ->andReturn($expectedResult);
    }

    private function expectExit(): void
    {
        $this->errorHelper->shouldReceive('exit');
    }

    private function expectLastError($expectedResult): void
    {
        $this->errorHelper
            ->shouldReceive('getLastError')
            ->once()
            ->andReturn($expectedResult);
    }

    private function expectErrorLoggedDirectly(string $expectedMessagePrefix)
    {
        $this->errorHelper
            ->shouldReceive('log')
            ->once()
            ->with(\Mockery::on(function ($message) use ($expectedMessagePrefix) {
                $this->assertStringContainsString($expectedMessagePrefix, $message);
                $this->assertStringContainsString($this->message, $message);
                $this->assertStringContainsString($this->file, $message);
                $this->assertStringContainsString((string)$this->line, $message);
                $this->assertStringContainsString((string)$this->errorCode, $message);
                return true;
            }));
    }

    private function expectSendErrorResponse(): void
    {
        $this->response->shouldReceive('sendError');
    }

    private function expectEventChecked(string $event, bool $expectedResult): void
    {
        $this->eventHandler
            ->shouldReceive('isRaised')
            ->with($event)
            ->andReturn($expectedResult)
            ->getMock();

        $this->pimpleContainer->setEventHandlerRegistry($this->eventHandler);
    }

    private function expectTerminatorCalled(bool $isFatalError): void
    {
        $this->terminator
            ->shouldReceive('terminate')
            ->once()
            ->with($isFatalError);
    }

    private function getErrorHandlerRegistry(?IResponse $response = null): ErrorHandlerRegistry
    {
        return new ErrorHandlerRegistry($this->idGenerator, $this->errorHelper, $response);
    }
}
